# Функция обновления заметки

# Загружаем модуль из библиотеки для работы с датой
from datetime import datetime

# Функция валидации даты, проверка введенной даты на соответствие требуемому формату
def validate_date(date_str):
    try:
        # Указываем необходимы формат, в данном случае дд:мм:гггг
        datetime.strptime(date_str, "%d:%m:%Y")
        return True
    # Обработка ошибки некорректного формата даты
    except ValueError:
        return False

# Функция обновления заметки
def update_note(note):
    print(' "Обновление заметки" ')
    print("Текущие данные заметки:")
    for key, value in note.items():
        print(f"{key}: {value}")

    updatable_fields = ["username", "title", "content", "status", "issue_date"]

    # Цикл запроса данных у пользователя, проверяем на ввод только данные которые должны соответствовать определенному
    # формату (статус и дедлайн), остальные параметры только на отсутствие пустого поля
    while True:
        # Запрос ввода поля для изменения
        field = input(f"\nКакие данные вы хотите обновить? ({', '.join(updatable_fields)}): ").strip().lower()

        # Проверка отсутствия пустого ввода
        if field not in updatable_fields:
            print(f"Ошибка: Поле '{field}' не найдено. Пожалуйста, выберите поле из списка.")
            continue

        # Изменение поля Дедлайн
        if field == "issue_date":
            # Запрашиваем ввод новой даты Дедлайна
            new_value = input(f"Введите новое значение для {field} ( В формате - дд:мм:гггг): ").strip()
            # Проверка правильного формата ввода данных
            if not validate_date(new_value):
                print("Ошибка: Неверный формат даты. Используйте формат 'дд:мм:гггг'.")
                continue

        # Изменение поля статус
        elif field == "status":
            # Создаем список возможных статусов
            status_options = ["новая", "в процессе", "выполнена"]
            # Запрашиваем ввод статуса и показываем возможные варианты статусов из списка
            new_value = input(f"Введите новый статус заметки ({"/".join(status_options)}): ").strip().lower()
            # Проверка правильности ввода в соответствии с существующими вариантами статуса
            while new_value not in status_options:
                print(f"Вы ввели неверный статус. Возможные варианты: {", ".join(status_options)}")
                new_value = input(f"Введите статус заметки ({"/".join(status_options)}): ").strip().lower()
            pass
        # Изменение остальных полей (Имя пользователя, заголовок заметки, описание заметки)
        else:
            new_value = input(f"Введите новое значение для {field}: ").strip().capitalize()
            if not new_value:
                print(f"Ошибка: Значение для {field} не может быть пустым.")
                continue

        # Информирование о замене поля (старое -> новое значения)
        note[field] = new_value
        print(f"\nЗаметка успешно обновлена: {field} -> {new_value}")

        # Повторны запрос на изменение еще одного поля
        another_update = input("\nХотите обновить ещё одно поле? (да/нет): ").strip().lower()
        if another_update != "да":
            break

    # Возвращаем созданный словарь из функции
    return note


if __name__ == "__main__":
    # Создаем вариант заметки для работы с функцией
    note = {
        "username": "Антон",
        "title": "Экзамен",
        "content": "Подготовиться к экзамену",
        "status": "новая",
        "created_date": "24-01-2025",
        "issue_date": "15-03-2025"
    }

    # Изменение поля в существующей заметке в соответствии с данными которые ввел пользователь
    updated_note = update_note(note)
    # Вывод обновленной заметки на экран
    print("\nОбновлённая заметка:")
    print(updated_note)
